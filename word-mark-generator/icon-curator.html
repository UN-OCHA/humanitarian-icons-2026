<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OCHA Icon Curator</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700;900&display=swap" rel="stylesheet">
    <style>
        /* OCHA Common Design System Variables */
        :root {
            --cd-ocha-blue: #1f69b3;
            --cd-blue--dark: #144372;
            --cd-blue--bright: #82b5e9;
            --cd-white: #fff;
            --cd-grey--light: #f2f2f2;
            --cd-grey--mid: #595959;
            --cd-grey--dark: #4a4a4a;
            --cd-blue-grey: #e6ecf1;
            --cd-font--roboto: 'Roboto', helvetica, arial, sans-serif;
            --cd-max-width: 1220px;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: var(--cd-font--roboto);
            background: var(--cd-blue-grey);
            min-height: 100vh;
            padding: 2rem 1rem;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: var(--cd-white);
            border-radius: 0;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            padding: 2.5rem;
        }

        h1 {
            color: var(--cd-ocha-blue);
            margin-bottom: 0.5rem;
            font-size: 2.5rem;
            font-weight: 700;
            line-height: 1.2;
        }

        .subtitle {
            color: var(--cd-grey--mid);
            margin-bottom: 2rem;
            font-weight: 400;
            font-size: 1.125rem;
        }

        .actions {
            display: flex;
            gap: 1rem;
            margin-bottom: 2rem;
            padding-bottom: 1.5rem;
            border-bottom: 1px solid var(--cd-grey--light);
            flex-wrap: wrap;
            align-items: center;
        }

        button {
            padding: 0.75rem 2rem;
            font-size: 0.875rem;
            font-weight: 700;
            border: 2px solid transparent;
            border-radius: 0;
            cursor: pointer;
            transition: all 0.2s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            box-shadow: none;
        }

        .btn-primary {
            background: var(--cd-ocha-blue);
            color: var(--cd-white);
            border-color: var(--cd-ocha-blue);
        }

        .btn-primary:hover {
            background: var(--cd-blue--dark);
            border-color: var(--cd-blue--dark);
        }

        .btn-secondary {
            background: var(--cd-grey--dark);
            color: var(--cd-white);
            border-color: var(--cd-grey--dark);
        }

        .btn-secondary:hover {
            background: var(--cd-grey--mid);
            border-color: var(--cd-grey--mid);
        }

        .stats {
            background: var(--cd-grey--light);
            padding: 1rem 1.5rem;
            border-radius: 0;
            margin-bottom: 1.5rem;
            border: 1px solid var(--cd-grey--light);
            font-size: 1rem;
            font-weight: 400;
            color: var(--cd-grey--dark);
        }

        .stats span {
            font-weight: 700;
            color: var(--cd-ocha-blue);
            font-size: 1.125rem;
        }

        .category-section {
            margin-bottom: 1.5rem;
            border: 1px solid var(--cd-grey--light);
            border-radius: 0;
            overflow: hidden;
            transition: none;
        }

        .category-section:hover {
            border-color: var(--cd-grey--light);
            box-shadow: none;
        }

        .category-header {
            background: var(--cd-ocha-blue);
            color: var(--cd-white);
            padding: 1rem 1.5rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            user-select: none;
        }

        .category-title {
            font-size: 1.125rem;
            font-weight: 700;
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .category-title input[type="text"] {
            background: var(--cd-white);
            color: var(--cd-blue--dark);
            padding: 0.5rem 1rem;
            border: none;
            border-radius: 0;
            font-size: 1rem;
            font-weight: 700;
            width: 350px;
        }

        .category-controls {
            display: flex;
            gap: 1rem;
            align-items: center;
        }

        .category-controls label {
            font-weight: 500;
            font-size: 0.875rem;
        }

        .category-controls input[type="checkbox"] {
            width: 20px;
            height: 20px;
            cursor: pointer;
            accent-color: var(--cd-white);
        }

        .category-controls button {
            padding: 0.5rem 1rem;
            font-size: 0.75rem;
        }

        .category-count {
            background: rgba(255,255,255,0.2);
            padding: 0.25rem 0.75rem;
            border-radius: 0;
            font-size: 0.875rem;
            font-weight: 500;
        }

        .category-body {
            padding: 1.5rem;
            background: var(--cd-white);
        }

        .category-body.collapsed {
            display: none;
        }

        .icon-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(240px, 1fr));
            gap: 1rem;
        }

        .icon-card {
            background: var(--cd-white);
            border: 1px solid var(--cd-grey--light);
            border-radius: 0;
            padding: 1rem;
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
            transition: border-color 0.2s ease;
        }

        .icon-card:hover {
            border-color: var(--cd-blue--bright);
            box-shadow: none;
            transform: none;
        }

        .icon-card-header {
            display: flex;
            gap: 0.75rem;
            align-items: center;
        }

        .icon-preview {
            width: 56px;
            height: 56px;
            flex-shrink: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--cd-grey--mid);
            font-size: 0.625rem;
            border: 1px solid var(--cd-grey--light);
            border-radius: 0;
            background: var(--cd-grey--light);
            transition: none;
        }

        .icon-card:hover .icon-preview {
            border-color: var(--cd-grey--light);
            background: var(--cd-grey--light);
        }

        .icon-preview svg {
            max-width: 52px;
            max-height: 52px;
        }

        .icon-info {
            flex: 1;
            min-width: 0;
        }

        .icon-name {
            font-weight: 700;
            font-size: 0.875rem;
            word-break: break-word;
            color: var(--cd-blue--dark);
            line-height: 1.4;
        }

        .icon-controls {
            display: flex;
            gap: 0.75rem;
            align-items: center;
            flex-wrap: wrap;
        }

        .icon-controls label {
            font-size: 0.75rem;
            color: var(--cd-grey--mid);
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
            flex-shrink: 0;
            accent-color: var(--cd-ocha-blue);
        }

        input[type="number"] {
            width: 70px;
            padding: 0.5rem;
            border: 1px solid var(--cd-grey--light);
            border-radius: 0;
            text-align: center;
            font-size: 0.875rem;
            flex-shrink: 0;
            font-weight: 500;
            transition: border-color 0.2s ease;
        }

        input[type="number"]:focus {
            outline: none;
            border-color: var(--cd-ocha-blue);
            box-shadow: none;
        }

        select {
            padding: 0.5rem 0.75rem;
            border: 1px solid var(--cd-grey--light);
            border-radius: 0;
            font-size: 0.875rem;
            background: var(--cd-white);
            cursor: pointer;
            max-width: 100%;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            font-weight: 500;
            color: var(--cd-blue--dark);
            transition: border-color 0.2s ease;
        }

        select:focus {
            outline: none;
            border-color: var(--cd-ocha-blue);
            box-shadow: none;
        }

        .loading {
            text-align: center;
            padding: 3rem;
            color: var(--cd-grey--mid);
            font-size: 1rem;
            font-weight: 400;
        }

        .uncategorized {
            background: var(--cd-grey--light);
        }

        @media (max-width: 768px) {
            .container {
                padding: 1.5rem;
            }

            h1 {
                font-size: 2rem;
            }

            .icon-grid {
                grid-template-columns: 1fr;
            }

            .actions {
                flex-direction: column;
                align-items: stretch;
            }

            .actions > div {
                margin-left: 0 !important;
            }

            button {
                width: 100%;
            }
        }

    </style>
</head>
<body>
    <div class="container">
        <h1>OCHA Icon Curator</h1>
        <p class="subtitle">Organize icons by category and configure vertical adjustments for wordmark generation</p>

        <div class="actions">
            <button class="btn-primary" onclick="exportJSON()" style="font-size: 16px; padding: 12px 24px;">üì• Export JSON</button>
            <div style="display: flex; gap: 8px; margin-left: auto;">
                <button class="btn-secondary" id="toggleSelectBtn" onclick="toggleSelectAll()">‚òëÔ∏è Deselect All</button>
                <button class="btn-secondary" id="toggleExpandBtn" onclick="toggleExpandAll()">‚ñº Collapse All</button>
            </div>
        </div>

        <div class="stats">
            <span id="selectedCount">0</span> icons selected out of <span id="totalCount">0</span> total
        </div>

        <div id="categoriesContainer">
            <div class="loading">Loading icons...</div>
        </div>
    </div>

    <input type="file" id="familyCsvFile" accept=".csv,text/csv" style="display: none;" onchange="handleFamilyCSVImport(event)">
    <input type="file" id="urlCsvFile" accept=".csv,text/csv" style="display: none;" onchange="handleUrlCSVImport(event)">

    <script>
        let icons = [];
        let categories = [];
        let csvFamilyOrder = [];
        let pendingFamilyCSVText = null;

        function normalizeIconName(value) {
            return (value || '')
                .toLowerCase()
                .replace(/&/g, 'and')
                .replace(/[\s\-_,.()\/]+/g, '')
                .trim();
        }

        function buildNormalizedCandidates(name) {
            const variants = new Set();
            const base = (name || '').trim();
            if (!base) return [];

            variants.add(base);
            // Match CSV names like "... (CCCM)" to repo filenames without abbreviation suffixes
            variants.add(base.replace(/\s*\([^)]*\)\s*/g, ' ').replace(/\s+/g, ' ').trim());
            // CSV uses "Hide" while repository filename is "hidden.svg"
            if (normalizeIconName(base) === 'hide') {
                variants.add('hidden');
            }

            const normalized = [];
            variants.forEach(v => {
                const n = normalizeIconName(v);
                if (n) normalized.push(n);
            });
            return Array.from(new Set(normalized));
        }

        function parseCSV(text) {
            const rows = [];
            let row = [];
            let field = '';
            let inQuotes = false;

            for (let i = 0; i < text.length; i++) {
                const char = text[i];
                const next = text[i + 1];

                if (char === '"') {
                    if (inQuotes && next === '"') {
                        field += '"';
                        i++;
                    } else {
                        inQuotes = !inQuotes;
                    }
                } else if (char === ',' && !inQuotes) {
                    row.push(field);
                    field = '';
                } else if ((char === '\n' || char === '\r') && !inQuotes) {
                    if (char === '\r' && next === '\n') i++;
                    row.push(field);
                    const trimmed = row.map(v => v.trim());
                    if (trimmed.some(v => v.length > 0)) {
                        rows.push(trimmed);
                    }
                    row = [];
                    field = '';
                } else {
                    field += char;
                }
            }

            if (field.length > 0 || row.length > 0) {
                row.push(field);
                const trimmed = row.map(v => v.trim());
                if (trimmed.some(v => v.length > 0)) {
                    rows.push(trimmed);
                }
            }

            return rows;
        }

        function showFamilyCSVPicker(message) {
            document.getElementById('categoriesContainer').innerHTML = `
                <div class="loading" style="color: #333;">
                    ${message}<br><br>
                    <button class="btn-primary" onclick="document.getElementById('familyCsvFile').click()">Select Humanitarian_icons_2026.csv</button>
                </div>
            `;
        }

        function parseUrlMappingsFromCSV(csvText) {
            const exactUrlMap = new Map();
            const normalizedUrlMap = new Map();
            const urlRows = parseCSV(csvText);
            const urlHeader = (urlRows[0] || []).map(h => h.toLowerCase());
            const nameIdx = urlHeader.indexOf('name');
            const variantIdx = urlHeader.indexOf('variant');
            const urlIdx = urlHeader.indexOf('url');

            if (nameIdx === -1 || variantIdx === -1 || urlIdx === -1) {
                throw new Error('Icon URL CSV is missing required columns (Name, Variant, URL).');
            }

            urlRows.slice(1).forEach(parts => {
                const name = (parts[nameIdx] || '').trim();
                const variant = (parts[variantIdx] || '').trim().toLowerCase().replace(/\s+/g, '-');
                const url = (parts[urlIdx] || '').trim();

                if ((variant === 'un-blue' || variant === 'unblue') && name && url) {
                    exactUrlMap.set(name, url);
                    normalizedUrlMap.set(normalizeIconName(name), url);
                }
            });

            return { exactUrlMap, normalizedUrlMap };
        }

        function humanizeIconNameFromPath(path) {
            const filename = path.split('/').pop().replace(/\.svg$/i, '');
            return filename
                .replace(/[_-]+/g, ' ')
                .replace(/\s+/g, ' ')
                .trim()
                .replace(/\b\w/g, c => c.toUpperCase());
        }

        function isUnBluePath(path) {
            const lower = path.toLowerCase();
            return lower.endsWith('.svg') && (lower.includes('/un-blue/') || lower.includes('/un_blue/') || lower.includes('/unblue/'));
        }

        function repoPathToCdnUrl(path) {
            const encodedPath = path.split('/').map(part => encodeURIComponent(part)).join('/');
            return `https://cdn.jsdelivr.net/gh/UN-OCHA/humanitarian-icons@main/${encodedPath}`;
        }

        async function loadRepoIconMappings() {
            const apiCandidates = [
                'https://api.github.com/repos/UN-OCHA/humanitarian-icons/git/trees/main?recursive=1',
                'https://api.github.com/repos/UN-OCHA/humanitarian-icons/git/trees/master?recursive=1'
            ];
            let treeData = null;
            let lastError = null;

            for (const url of apiCandidates) {
                try {
                    const response = await fetch(url);
                    if (!response.ok) throw new Error(`HTTP ${response.status}`);
                    treeData = await response.json();
                    if (treeData && Array.isArray(treeData.tree)) break;
                    throw new Error('Invalid tree payload');
                } catch (err) {
                    lastError = err;
                }
            }

            if (!treeData || !Array.isArray(treeData.tree)) {
                throw lastError || new Error('Could not read repository tree.');
            }

            const exactUrlMap = new Map();
            const normalizedUrlMap = new Map();

            treeData.tree
                .filter(item => item && item.type === 'blob' && isUnBluePath(item.path || ''))
                .forEach(item => {
                    const name = humanizeIconNameFromPath(item.path);
                    const cdnUrl = repoPathToCdnUrl(item.path);
                    exactUrlMap.set(name, cdnUrl);
                    normalizedUrlMap.set(normalizeIconName(name), cdnUrl);
                });

            return { exactUrlMap, normalizedUrlMap };
        }

        function showUrlCSVHint() {
            const stats = document.querySelector('.stats');
            if (!stats) return;
            const existing = document.getElementById('urlCsvHint');
            if (existing) existing.remove();
            stats.insertAdjacentHTML(
                'beforeend',
                `<div id="urlCsvHint" style="margin-top:8px;color:#b45309;font-weight:600;">Could not load icon files from the humanitarian-icons repository. <button class="btn-secondary" style="margin-left:8px;padding:6px 10px;font-size:12px;" onclick="document.getElementById('urlCsvFile').click()">Select OCHA_Humanitarian_Icons_URLs.csv</button></div>`
            );
        }

        async function loadIcons(overrideFamilyCSV = null, overrideUrlCSV = null) {
            try {
                // Load Family/Icon source of truth from local CSV
                let categoryCSV = '';
                if (overrideFamilyCSV) {
                    categoryCSV = overrideFamilyCSV.replace(/^\uFEFF/, '');
                } else {
                    try {
                        const categoryResponse = await fetch('./Humanitarian_icons_2026.csv');
                        if (!categoryResponse.ok) {
                            throw new Error(`HTTP ${categoryResponse.status}`);
                        }
                        categoryCSV = (await categoryResponse.text()).replace(/^\uFEFF/, '');
                    } catch (err) {
                        console.error('Could not auto-load Humanitarian_icons_2026.csv:', err);
                        showFamilyCSVPicker('Could not load <strong>Humanitarian_icons_2026.csv</strong> automatically.');
                        return;
                    }
                }
                const categoryRows = parseCSV(categoryCSV);
                pendingFamilyCSVText = categoryCSV;

                if (categoryRows.length < 2) {
                    throw new Error('Family mapping CSV is empty or invalid.');
                }

                const header = categoryRows[0].map(h => h.toLowerCase());
                const familyIdx = header.indexOf('family');
                const iconIdx = header.indexOf('icon name');

                if (familyIdx === -1 || iconIdx === -1) {
                    throw new Error('CSV must include "Family" and "Icon Name" columns.');
                }

                const familyIconRows = categoryRows
                    .slice(1)
                    .map(r => ({
                        family: (r[familyIdx] || '').trim(),
                        iconName: (r[iconIdx] || '').trim()
                    }))
                    .filter(r => r.family && r.iconName);

                const familySet = new Set();
                csvFamilyOrder = [];
                familyIconRows.forEach(r => {
                    if (!familySet.has(r.family)) {
                        familySet.add(r.family);
                        csvFamilyOrder.push(r.family);
                    }
                });

                let exactUrlMap = new Map();
                let normalizedUrlMap = new Map();
                try {
                    if (overrideUrlCSV) {
                        ({ exactUrlMap, normalizedUrlMap } = parseUrlMappingsFromCSV(overrideUrlCSV));
                    } else {
                        ({ exactUrlMap, normalizedUrlMap } = await loadRepoIconMappings());
                    }
                } catch (err) {
                    console.warn('Could not load icon URLs from repository. Continuing without previews/URLs.', err);
                    showUrlCSVHint();
                }

                const usedNames = new Set();

                icons = familyIconRows.map(({ family, iconName }) => {
                    const candidates = buildNormalizedCandidates(iconName);
                    let url = exactUrlMap.get(iconName) || '';
                    if (!url) {
                        for (const candidate of candidates) {
                            const match = normalizedUrlMap.get(candidate);
                            if (match) {
                                url = match;
                                break;
                            }
                        }
                    }

                    usedNames.add(iconName);
                    return {
                        name: iconName,
                        url,
                        included: true,
                        verticalAdjustment: 0,
                        category: family
                    };
                });

                // Do not auto-add repository icons that are not in the Family/Icon CSV.
                // This keeps curator structure aligned with the spreadsheet.

                // Try to load curated-icons.json to restore selection state
                try {
                    const curatedResponse = await fetch('./curated-icons.json');
                    if (curatedResponse.ok) {
                        const curatedData = await curatedResponse.json();
                        if (curatedData.icons && Array.isArray(curatedData.icons)) {
                            // First, mark all icons as not included
                            icons.forEach(icon => icon.included = false);

                            // Then mark icons that are in curated-icons.json as included
                            const curatedNames = new Set(curatedData.icons.map(i => i.name));
                            icons.forEach(icon => {
                                if (curatedNames.has(icon.name)) {
                                    icon.included = true;
                                    // Also restore vertical adjustment and category if available
                                    const curatedIcon = curatedData.icons.find(i => i.name === icon.name);
                                    if (curatedIcon) {
                                        icon.verticalAdjustment = curatedIcon.verticalAdjustment || 0;
                                        if (curatedIcon.category) {
                                            icon.category = curatedIcon.category;
                                        }
                                    }
                                }
                            });
                            console.log('Loaded curated selection state:', curatedNames.size, 'icons selected');
                        }
                    }
                } catch (err) {
                    console.log('No curated-icons.json found, defaulting to all icons selected');
                }

                buildCategoriesFromIcons();
                renderCategories();
                updateStats();
            } catch (error) {
                document.getElementById('categoriesContainer').innerHTML =
                    `<div class="loading" style="color: red;">Error loading icons: ${error.message}</div>`;
                console.error('Error loading icons:', error);
            }
        }

        function handleFamilyCSVImport(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                const csvText = e.target.result;
                loadIcons(csvText);
            };
            reader.readAsText(file);
        }

        function handleUrlCSVImport(event) {
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (e) => {
                const urlCsvText = e.target.result;
                loadIcons(pendingFamilyCSVText, urlCsvText);
            };
            reader.readAsText(file);
        }

        function buildCategoriesFromIcons() {
            const categoriesMap = new Map();

            // Start with Family order exactly as provided in CSV
            csvFamilyOrder.forEach(family => {
                categoriesMap.set(family, []);
            });

            icons.forEach(icon => {
                if (!categoriesMap.has(icon.category)) {
                    categoriesMap.set(icon.category, []);
                }
                categoriesMap.get(icon.category).push(icon);
            });

            const orderedNames = [];

            csvFamilyOrder.forEach(name => {
                if (categoriesMap.has(name)) orderedNames.push(name);
            });

            // Add user-added/renamed categories (except Uncategorized) in alpha order after CSV families
            const additional = Array.from(categoriesMap.keys())
                .filter(name => !csvFamilyOrder.includes(name) && name !== 'Uncategorized')
                .sort((a, b) => a.localeCompare(b));
            orderedNames.push(...additional);

            if (categoriesMap.has('Uncategorized')) {
                orderedNames.push('Uncategorized');
            }

            categories = orderedNames.map(name => ({
                name,
                icons: categoriesMap.get(name)
            }));
        }

        function renderCategories() {
            const container = document.getElementById('categoriesContainer');
            container.innerHTML = '';

            categories.forEach((category, catIndex) => {
                const section = document.createElement('div');
                section.className = 'category-section';

                const header = document.createElement('div');
                header.className = 'category-header' + (category.name === 'Uncategorized' ? ' uncategorized' : '');

                // Create body element FIRST so it's available in the closure
                const body = document.createElement('div');
                body.className = 'category-body';

                const titleDiv = document.createElement('div');
                titleDiv.className = 'category-title';
                titleDiv.style.cursor = 'pointer';
                titleDiv.onclick = (e) => {
                    e.stopPropagation();
                    body.classList.toggle('collapsed');
                };

                const nameSpan = document.createElement('span');
                nameSpan.textContent = category.name;
                nameSpan.style.fontWeight = '700';
                nameSpan.style.fontSize = '18px';

                const count = document.createElement('span');
                count.className = 'category-count';
                count.textContent = `${category.icons.length} icons`;

                titleDiv.appendChild(nameSpan);
                titleDiv.appendChild(count);

                const controls = document.createElement('div');
                controls.className = 'category-controls';
                controls.onclick = (e) => {
                    e.stopPropagation();
                };

                const selectAllLabel = document.createElement('label');
                selectAllLabel.textContent = 'All: ';
                selectAllLabel.style.color = 'white';
                selectAllLabel.style.marginRight = '5px';
                selectAllLabel.onclick = (e) => {
                    e.stopPropagation();
                };

                const selectAllCheckbox = document.createElement('input');
                selectAllCheckbox.type = 'checkbox';
                selectAllCheckbox.checked = category.icons.length > 0 && category.icons.every(icon => icon.included);
                selectAllCheckbox.onclick = (e) => {
                    e.stopPropagation();
                };
                selectAllCheckbox.onchange = (e) => {
                    e.stopPropagation();
                    const checked = e.target.checked;
                    category.icons.forEach(icon => {
                        icon.included = checked;
                    });
                    // Update individual checkboxes in-place without re-rendering
                    body.querySelectorAll('.icon-card .icon-controls input[type="checkbox"]').forEach(cb => {
                        cb.checked = checked;
                    });
                    updateStats();
                };

                controls.appendChild(selectAllLabel);
                controls.appendChild(selectAllCheckbox);

                header.appendChild(titleDiv);
                header.appendChild(controls);

                const grid = document.createElement('div');
                grid.className = 'icon-grid';

                category.icons.forEach(icon => {
                    const card = document.createElement('div');
                    card.className = 'icon-card';

                    const cardHeader = document.createElement('div');
                    cardHeader.className = 'icon-card-header';

                    const preview = document.createElement('div');
                    preview.className = 'icon-preview';
                    if (icon.url) {
                        fetch(icon.url)
                            .then(r => r.text())
                            .then(svgText => {
                                preview.innerHTML = svgText;
                            })
                            .catch(() => {
                                preview.textContent = 'No preview';
                            });
                    } else {
                        preview.textContent = 'No URL';
                    }

                    const info = document.createElement('div');
                    info.className = 'icon-info';
                    const name = document.createElement('div');
                    name.className = 'icon-name';
                    name.textContent = icon.name;
                    info.appendChild(name);

                    cardHeader.appendChild(preview);
                    cardHeader.appendChild(info);

                    const controlsDiv = document.createElement('div');
                    controlsDiv.className = 'icon-controls';

                    const includeCheck = document.createElement('input');
                    includeCheck.type = 'checkbox';
                    includeCheck.checked = icon.included;
                    includeCheck.onchange = (e) => {
                        icon.included = e.target.checked;
                        updateStats();
                    };

                    const adjLabel = document.createElement('label');
                    adjLabel.textContent = 'V.Adj:';

                    const adjInput = document.createElement('input');
                    adjInput.type = 'number';
                    adjInput.value = icon.verticalAdjustment;
                    adjInput.min = -20;
                    adjInput.max = 20;
                    adjInput.step = 1;
                    adjInput.onchange = (e) => {
                        icon.verticalAdjustment = parseInt(e.target.value, 10) || 0;
                    };

                    const catSelect = document.createElement('select');
                    categories.forEach(cat => {
                        const option = document.createElement('option');
                        option.value = cat.name;
                        option.textContent = cat.name;
                        option.selected = icon.category === cat.name;
                        catSelect.appendChild(option);
                    });
                    catSelect.onchange = (e) => {
                        icon.category = e.target.value;
                        buildCategoriesFromIcons();
                        renderCategories();
                    };

                    controlsDiv.appendChild(includeCheck);
                    controlsDiv.appendChild(adjLabel);
                    controlsDiv.appendChild(adjInput);
                    controlsDiv.appendChild(catSelect);

                    card.appendChild(cardHeader);
                    card.appendChild(controlsDiv);

                    grid.appendChild(card);
                });

                body.appendChild(grid);

                section.appendChild(header);
                section.appendChild(body);

                container.appendChild(section);
            });

            document.getElementById('totalCount').textContent = icons.length;
        }

        function updateStats() {
            const selected = icons.filter(icon => icon.included).length;
            document.getElementById('selectedCount').textContent = selected;

            // Update toggle button state
            const toggleBtn = document.getElementById('toggleSelectBtn');
            if (toggleBtn) {
                const allSelected = icons.length > 0 && icons.every(icon => icon.included);
                toggleBtn.textContent = allSelected ? '‚òëÔ∏è Deselect All' : '‚òê Select All';
            }
        }

        function toggleSelectAll() {
            const btn = document.getElementById('toggleSelectBtn');
            const allSelected = icons.every(icon => icon.included);

            if (allSelected) {
                // Deselect all
                icons.forEach(icon => icon.included = false);
                btn.textContent = '‚òê Select All';
            } else {
                // Select all
                icons.forEach(icon => icon.included = true);
                btn.textContent = '‚òëÔ∏è Deselect All';
            }

            renderCategories();
            updateStats();
        }

        function toggleExpandAll() {
            const btn = document.getElementById('toggleExpandBtn');
            const bodies = document.querySelectorAll('.category-body');
            const allExpanded = Array.from(bodies).every(body => !body.classList.contains('collapsed'));

            if (allExpanded) {
                // Collapse all
                bodies.forEach(body => body.classList.add('collapsed'));
                btn.textContent = '‚ñ∂ Expand All';
            } else {
                // Expand all
                bodies.forEach(body => body.classList.remove('collapsed'));
                btn.textContent = '‚ñº Collapse All';
            }
        }

        async function exportJSON() {
            const data = {
                categories: categories.map(cat => ({
                    name: cat.name,
                    icons: cat.icons.map(icon => icon.name)
                })),
                icons: icons
                    .filter(icon => icon.included && icon.url && icon.url.trim() !== '')
                    .map(icon => ({
                        name: icon.name,
                        url: icon.url,
                        verticalAdjustment: icon.verticalAdjustment,
                        category: icon.category
                    }))
            };

            const json = JSON.stringify(data, null, 2);

            // Try to save using File System Access API (modern browsers)
            try {
                // Check if File System Access API is supported
                if ('showSaveFilePicker' in window) {
                    const options = {
                        suggestedName: 'curated-icons.json',
                        types: [{
                            description: 'JSON Files',
                            accept: { 'application/json': ['.json'] }
                        }]
                    };

                    const handle = await window.showSaveFilePicker(options);
                    const writable = await handle.createWritable();
                    await writable.write(json);
                    await writable.close();

                    alert(`Exported ${data.icons.length} icons with ${categories.length} categories to curated-icons.json`);
                } else {
                    // Fallback to download
                    throw new Error('File System Access API not supported');
                }
            } catch (err) {
                // User cancelled or API not supported - fallback to download
                if (err.name !== 'AbortError') {
                    console.log('Falling back to download method');
                }

                const blob = new Blob([json], { type: 'application/json' });
                const url = URL.createObjectURL(blob);

                const a = document.createElement('a');
                a.href = url;
                a.download = 'curated-icons.json';
                a.click();

                URL.revokeObjectURL(url);

                alert(`Downloaded ${data.icons.length} icons with ${categories.length} categories as curated-icons.json\n\nNote: Save this file to the same folder as the generator.`);
            }
        }

        // Initialize
        loadIcons();
    </script>
</body>
</html>
